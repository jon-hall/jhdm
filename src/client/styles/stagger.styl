@import 'util'

sp(expr)
    expr ? ' ' + expr : ''

$stagger-defaults = {
    duration: 0.5s,
    timing: linear,
    direction: '',
    fillmode: '',
    delay: 0s
}

/**
 * Allows easily staggering a sequence of animations.
 * @example
 * .aclass
 *     animation stagger({
 *         animation-one: {
 *             duration: 0.2s,
 *             timing: ease-in-out,
 *             direction: reverse,
 *             iterations: 3,
 *             fillmode: backwards,
 *             delay: 0.5s
 *         },
 *         animation-two: {
 *             duration: 0.4s,
 *             delay: 0.1s
 *         }
 *     })
 * @param  {Object} anims  A hash containing animation names as keys, and properties for that animation
 * as values.
 * @param  {Object} common = {} The common defaults for animation properties which should be applied to
 * all animations in the hash.
 * @return {any}  The value for a CSS 'animation' property.
 */
stagger(anims, common = {})
    $value = ()
    $delay = offset in common ? common.offset : 0s
    for anim, config in anims
        $duration = coalesce('duration', config, common, $stagger-defaults)
        $timing = coalesce('timing', config, common, $stagger-defaults)
        $direction = coalesce('direction', config, common, $stagger-defaults)
        $iterations = coalesce('iterations', config, common, $stagger-defaults)
        // TODO: Could, techincally, support it on the last animation...
        if $iterations == infinite
            error('Stagger does not support infinite iterations')
        $fillmode = coalesce('fillmode', config, common, $stagger-defaults)
        $delay += coalesce('delay', config, common, $stagger-defaults)
        push($value, anim + sp($duration) + sp($timing) + sp($delay) + sp($direction) + sp($iterations) + sp($fillmode))
        $delay += $duration * ($iterations ? $iterations : 1)
    unquote(join(', ', $value))
